package ibf_tfip.mini_project.backend.repositories;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.springframework.stereotype.Repository;

import com.google.api.core.ApiFuture;
import com.google.cloud.firestore.CollectionReference;
import com.google.cloud.firestore.DocumentReference;
import com.google.cloud.firestore.DocumentSnapshot;
import com.google.cloud.firestore.Firestore;
import com.google.cloud.firestore.QueryDocumentSnapshot;
import com.google.cloud.firestore.QuerySnapshot;
import com.google.cloud.firestore.WriteResult;
import com.google.firebase.FirebaseApp;
import com.google.firebase.cloud.FirestoreClient;
import com.google.firebase.database.DataSnapshot;
import com.google.firebase.database.DatabaseError;
import com.google.firebase.database.DatabaseReference;
import com.google.firebase.database.FirebaseDatabase;
import com.google.firebase.database.Query;
import com.google.firebase.database.ValueEventListener;

import ibf_tfip.mini_project.backend.models.MainThread.QuestionSubThread;
import ibf_tfip.mini_project.backend.models.MainThread.ThreadContent;
import ibf_tfip.mini_project.backend.models.Question;
import ibf_tfip.mini_project.backend.models.QuestionSummary;

@Repository
public class FirebaseRepo {
    
    private final DatabaseReference databaseRef;
    private final Firestore firestore;

    private final String databaseName = "threads";
    private final String firestoreCollectionName = "interviewQuest";


    public FirebaseRepo(FirebaseApp firebaseApp) {
        this.databaseRef = FirebaseDatabase.getInstance(firebaseApp).getReference(databaseName);
        this.firestore = FirestoreClient.getFirestore();
    }


    //// Realtime Database /////////////////////////////////////////////////////////////////
    // Intial thread is the first thread when user first submit form data and get response from AI
    // https://firebase.google.com/docs/database/admin/save-data
    public String saveFirstSubThreadToFB(
        String userId, 
        List<ThreadContent> firstSubThread,  
        String customJobId, 
        String assistantId, 
        String threadId) throws IOException {

        String autoGeneratedKey = databaseRef.child(userId).push().getKey(); // Generate a new unique key
        DatabaseReference threadRef = databaseRef
            .child(userId)
            .child(autoGeneratedKey);

        threadRef.child("customJobId").setValueAsync(customJobId);
        threadRef.child("assistantId").setValueAsync(assistantId);
        threadRef.child("threadId").setValueAsync(threadId);

        DatabaseReference ref = threadRef.child("firstSubThread");
        for(ThreadContent tc : firstSubThread) {
            ref.push().setValueAsync(tc);
        }
        return autoGeneratedKey;
    }


    // Get firstSubThread - (then we will parse and save qns to Firestore)
    // https://firebase.google.com/docs/database/admin/retrieve-data
    public List<ThreadContent> getFirstSubThreadFrFB(
        String userId,
        String key) throws InterruptedException, TimeoutException {

        DatabaseReference ref = databaseRef
            .child(userId)
            .child(key)
            .child("firstSubThread");
        final List<ThreadContent> firstSubThread = new ArrayList<>();
        final CountDownLatch latch = new CountDownLatch(1); // Used for synchronization

        ref.addValueEventListener(new ValueEventListener() {

            @Override
            public void onDataChange(DataSnapshot dataSnapshot) {
                if (dataSnapshot.exists()) {
                    for (DataSnapshot snapshot : dataSnapshot.getChildren()) {
                        ThreadContent threadContent = snapshot.getValue(ThreadContent.class);
                        if (threadContent != null) {
                            firstSubThread.add(threadContent);
                        }
                    }
                } else {
                    System.out.println("No data found at the specified reference.");
                }
                latch.countDown();  // Signal that the data has been fetched
            }

            @Override
            public void onCancelled(DatabaseError databaseError) {
                System.out.println("The read failed: " + databaseError.getCode());
                latch.countDown(); // Ensure latch is counted down even on failure
            }
        });

        if (!latch.await(10, TimeUnit.SECONDS)) { // Wait for a maximum of 10 seconds
            throw new TimeoutException("Timed out waiting for Firebase response");
        }
        return firstSubThread;
    }


    // Add questionSubThread to the main Thread
    // https://firebase.google.com/docs/database/admin/save-data
    public void saveQuestionSubThreadToFB(
        String userId, 
        QuestionSubThread qnsThread, 
        String key) {

        try {
            DatabaseReference qnsThreadRef = databaseRef
                .child(userId)
                .child(key)
                .child("questionSubThread");
            Query query = qnsThreadRef
                .orderByChild("questionId")
                .equalTo(qnsThread.getQuestionId());

            query.addListenerForSingleValueEvent(new ValueEventListener() {
                
                @Override
                public void onDataChange(DataSnapshot dataSnapshot) {
                    DatabaseReference qnsRef;
                    if (dataSnapshot.exists()) {
                        // If questionId already exists, append to the existing threadContent
                        DataSnapshot existingQuestionSnapshot = dataSnapshot
                            .getChildren()
                            .iterator()
                            .next();
                        qnsRef = existingQuestionSnapshot.getRef();
                    } else {
                        // QuestionId does not exist, create a new entry
                        String autoGeneratedKey = qnsThreadRef.push().getKey();
                        qnsRef = qnsThreadRef.child(autoGeneratedKey);
                        qnsRef.child("questionId").setValueAsync(qnsThread.getQuestionId());
                        qnsRef.child("questionType").setValueAsync(qnsThread.getQuestionType());
                        qnsRef.child("question").setValueAsync(qnsThread.getQuestion());
                    }

                    // Add the questionThreadContent data
                    DatabaseReference contentRef = qnsRef.child("questionThreadContent");
                    for (ThreadContent tc : qnsThread.getThreadContents()) {
                        contentRef.push().setValueAsync(tc);
                    }
                }

                @Override
                public void onCancelled(DatabaseError databaseError) {
                    System.out.println("Error checking questionId: " + databaseError.getCode());
                }
            });
        } catch (Exception e) {
            System.out.println("Error saving question thread to the main thread...");
        }
    }


    // https://firebase.google.com/docs/database/admin/retrieve-data
    public List<QuestionSummary> getListOfQuestionSummaryFrFB(
        String userId, 
        String key) throws InterruptedException, TimeoutException {

        DatabaseReference ref = databaseRef.child(userId).child(key).child("questionSubThread");
        final List<QuestionSummary> listOfQuestionSummaries = new ArrayList<>();
        final CountDownLatch latch = new CountDownLatch(1); // Used for synchronization
    
        ref.addListenerForSingleValueEvent(new ValueEventListener() {
    
            @Override
            public void onDataChange(DataSnapshot dataSnapshot) {
                if (dataSnapshot.exists()) {
                    for (DataSnapshot snapshot : dataSnapshot.getChildren()) {
                        // System.out.println("Data for snapshot: " + snapshot.getValue());
                        
                        // Convert snapshot value to QuestionSubThread
                        QuestionSubThread questionSubThread = snapshot.getValue(QuestionSubThread.class);
                        if (questionSubThread != null) {
                            QuestionSummary summary = new QuestionSummary(
                                questionSubThread.getQuestionId(),
                                questionSubThread.getQuestionType(),
                                questionSubThread.getQuestion()
                            );
                            listOfQuestionSummaries.add(summary);
                        } else {
                            System.out.println("QuestionSubThread is null for snapshot key: " + snapshot.getKey());
                        }
                    }
                } else {
                    System.out.println("No data found at the specified reference.");
                }
                latch.countDown();  // Signal that the data has been fetched
            }
    
            @Override
            public void onCancelled(DatabaseError databaseError) {
                System.out.println("The read failed: " + databaseError.getCode());
                latch.countDown(); // Ensure latch is counted down even on failure
            }
        });
    
        if (!latch.await(10, TimeUnit.SECONDS)) { // Wait for a maximum of 10 seconds
            throw new TimeoutException("Timed out waiting for Firebase response");
        }
        return listOfQuestionSummaries;
    }


    // https://firebase.google.com/docs/database/admin/retrieve-data
    public List<ThreadContent> getQuestionSubThreadContentsByQnsIdFrFB(
        String userId, 
        String key, 
        String qnsId) throws InterruptedException, TimeoutException {

        DatabaseReference ref = databaseRef
            .child(userId)
            .child(key)
            .child("questionSubThread");
        final List<ThreadContent> questionSubThreadContents = new ArrayList<>();
        final CountDownLatch latch = new CountDownLatch(1); // Used for synchronization
    
        ref.orderByChild("questionId").equalTo(qnsId).addListenerForSingleValueEvent(new ValueEventListener() {
    
            @Override
            public void onDataChange(DataSnapshot dataSnapshot) {
                if (dataSnapshot.exists()) {
                    DataSnapshot questionSnapshot = dataSnapshot.getChildren().iterator().next();
                    DataSnapshot contentSnapshot = questionSnapshot.child("questionThreadContent");
                    for (DataSnapshot threadContentSnapshot : contentSnapshot.getChildren()) {
                        ThreadContent threadContent = threadContentSnapshot.getValue(ThreadContent.class);
                        if (threadContent != null) {
                            questionSubThreadContents.add(threadContent);
                        }
                    }
                } else {
                    System.out.println("No data found at the specified reference.");
                }
                latch.countDown();  // Signal that the data has been fetched
            }
    
            @Override
            public void onCancelled(DatabaseError databaseError) {
                System.out.println("The read failed: " + databaseError.getCode());
                latch.countDown(); // Ensure latch is counted down even on failure
            }
        });
    
        if (!latch.await(10, TimeUnit.SECONDS)) { // Wait for a maximum of 10 seconds
            throw new TimeoutException("Timed out waiting for Firebase response");
        }
        return questionSubThreadContents;
    }
    
    
    //// Firestore /////////////////////////////////////////////////////////////////////////
    // https://firebase.google.com/docs/firestore/manage-data/add-data
    public void saveInterviewQnsToFS(
        String userId, 
        List<Question> qnsList, 
        String customJobId) throws InterruptedException, ExecutionException {

        CollectionReference colRef = firestore.collection(firestoreCollectionName);
        DocumentReference docRef = colRef.document(userId + "_" + customJobId);
        
        Map<String, Object> data = new HashMap<>();
        for (Question qns : qnsList) {
            data.put(qns.getQuestionId(), qns); // Add each question to the data map
        }
        
        ApiFuture<WriteResult> result = docRef.set(data); // Set the complete map once
        System.out.println("From Firestore - Update time : " + result.get().getUpdateTime());
    }

    
    // https://firebase.google.com/docs/firestore/query-data/get-data
    // No need userId since it is part of collection name
    public List<Question> getAllInterviewQnsFrFS(
        String userId,
        String customJobId) throws InterruptedException, ExecutionException {

        // asynchronously retrieve the document
        ApiFuture<QuerySnapshot> future = firestore
            .collection(firestoreCollectionName)
            .whereEqualTo(userId + "_" + customJobId, true).get();

        // future.get() blocks on response
        List<QueryDocumentSnapshot> documents = future.get().getDocuments();

        List<Question> qnsList = new ArrayList<>();

        for (DocumentSnapshot doc : documents) {
            qnsList.add(doc.toObject(Question.class));
        }

        return qnsList;
    }


    // https://firebase.google.com/docs/firestore/query-data/get-data
    // No need userId since it is part of collection name
    @SuppressWarnings("unchecked")
    public Question getInterviewQnsByQnsIdFrFS (
        String userId,
        String customJobId, 
        String qnsId) throws InterruptedException, ExecutionException {

        DocumentReference docRef = firestore
            .collection(firestoreCollectionName)
            .document(userId + "_" + customJobId);

        // asynchronously retrieve the document
        ApiFuture<DocumentSnapshot> future = docRef.get();

        // future.get() blocks on response
        DocumentSnapshot document = future.get();

        if (document.exists()) {
            // Retrieve the nested field (which is a Map) using the qnsId as the key
            Map<String, Object> questionData = (Map<String, Object>) document.get(qnsId);
    
            if (questionData != null) {
                // Manually map the fields to a Question object
                String questionId = (String) questionData.get("questionId");
                String questionType = (String) questionData.get("questionType");
                String question = (String) questionData.get("question");
                String suggestedAnswerApproach = (String) questionData.get("suggestedAnswerApproach");
    
                // Create and return Question object
                return new Question(questionId, questionType, question, suggestedAnswerApproach);
            } else {
                System.out.println("No such question field found for qnsId: " + qnsId);
            }
        } else {
            System.out.println("No such document for customJobId: " + customJobId);
        }
        return null;
    }
}
